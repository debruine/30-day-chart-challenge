# (PART) Comparisons {-}

# Part-to-whole

```{r}
library(treemap)
library(faux)
library(tidyverse)
```

I've been wanting to get more familiar with treemap plots. 

## Simulate data

I always like to start my exploration with simulated data. The mixed design simulation functions below are from [faux](https://debruine.github.io/faux/articles/sim_mixed.html).

Make a school with 5 grades, 1-4 classes per grade, and 15-35 students per class. Get some random names from the 2010 Scottish babies.

```{r pth-data-sim}
set.seed(8675309) # for reproducible data simulation

school <- add_random(grade = 5) %>%
  add_random(class = sample(1:4, nrow(.), TRUE), 
             .nested_in = "grade") %>%
  add_random(student = sample(15:35, nrow(.), TRUE), 
             .nested_in = "class") %>%
  mutate(name = sample(size = nrow(.),
                       x = ukbabynames::scotbabynames %>%
                         filter(year == 2010) %>%
                         pull(name)))

head(school)
```

## Basic Treemap

The basic version is OK, but I think we can do better here.

```{r pth-treemap-basic}
school %>% 
  count(grade, class) %>%
  treemap(
    index = c("grade", "class"), 
    vSize = "n"
  )
```

## Adjust Labels

First, I'll adjust the label size and alignment. I adapted this code from a book that Emily Nordmann and I recently wrote: [Applied Data Skills](https://psyteachr.github.io/ads-v1/custom.html#treemap). For `fontsize.labels` and `align.labels`, I added vector names to help me remember which is which, but the names aren't used by `treemap()` at all, just the order.

The class labels aligned to the bottom right are too close to the edges, so give them some padding with `xmod.labels` and `ymod.labels`. I'm also going to remove the transparent grey label background with `bg.labels = 0`

```{r pth-treemap-labels}
school %>% 
  count(grade, class) %>%
  treemap(
    index = c("grade", "class"), 
    vSize = "n", 
    title = "",
    # set different label sizes for each type of label
    fontsize.labels = c(grade = 30, class = 15), 
    # remove shaded background
    bg.labels = 0,
    # set different alignments for two label types
    align.labels = list(
      grade = c("left", "top"), 
      class = c("right", "bottom")
    ),
    xmod.labels = c(0, -.1), # nudge class labels left
    ymod.labels = c(0, .1)   # nudge class labels up
  )
```

## Colour scheme

I'd like to use the #30DayChartChallenge theme colours for my plots, so let's set that up. I'm going to name the colours after the chapter they represent.

```{r pth-dcc-colours}
dcc_theme <- list(
  comp = "#4864DB", # ~royalblue
  dist = "#10D4CF", # ~darkturquoise
  rels = "#8DEA74", # ~lightgreen
  time = "#F5C748", # ~tan1
  cert = "#EA4E11"  # ~orangered2
)
```

```{r pth-treemap-colours}
school %>% 
  count(grade, class) %>%
  treemap(
    index = c("grade", "class"), 
    vSize = "n", 
    title = "",
    palette = dcc_theme,
    fontsize.labels = c(grade = 30, class = 10), 
    bg.labels = 0,
    align.labels = list(
      grade = c("left", "top"), 
      class = c("center", "center")
    ),
    xmod.labels = c(0, -.1),
    ymod.labels = c(0, .1)
  )
```

## Change text

Now I want to upgrade the labels. It's probably easiest to do this in the data using `mutate()`. I'll set them to the kind of primary school grade labels we use in Scotland, where each grade is P1, P2, ... and each class within a grade gets a letter suffix. 

```{r school2}
school2 <- school %>% 
  count(grade, class) %>%
  mutate(grade = gsub("grade", "P", grade)) %>%
  group_by(grade) %>%
  mutate(class = paste0(grade, letters[1:n()])) %>%
  ungroup() %>%
  mutate(class = paste0(class, "\nn = ", n))
```

Finally, make the borders thicker. It's starting to look like a Mondrian!.

```{r pth-treemap-final, fig.cap = "Treemap plot of classes nested in grades (P1 to P5). There are 2-4 classes in each grade with 16-35 students. The size of each box represents the size of the class, and the colour of the box represents the grade."}
school2 %>%
  treemap(
    index = c("grade", "class"), 
    vSize = "n", 
    title = "",
    palette = dcc_theme,
    fontcolor.labels = "white",
    fontsize.labels = c(grade = 30, class = 15), 
    bg.labels = 0,
    align.labels = list(
      grade = c("left", "top"), 
      class = c("right", "bottom")
    ),
    xmod.labels = c(0, -.1),
    ymod.labels = c(0, .1),
    border.lwds = 5, # thicker borders
  )
```


```{r, include = FALSE}
ggsave("images/day1.png", width = 8, height = 4.5)
```

# Pictogram

I recently discovered the `r pkg("waffle", "https://github.com/hrbrmstr/waffle/")` package for making waffle plots. Emily and I refuse to teach students on our [Applied Data Skills](https://psyteachr.github.io/ads-v1/) course how to make pie charts, and these are a sweet alternative. 

```{r}
#devtools::install_github("hrbrmstr/waffle")
library(tidyverse)
library(waffle)
```


## Pictogram data

Pictograms are generally used for counts, and pets are my go-to example for unordered categorical data (even though ferrets are obviously the best).

I found a table of [pet ownership in the USA](https://www.iii.org/fact-statistic/facts-statistics-pet-ownership-and-insurance). They had an excel file download option for the data, but the file was corrupted, so I used `r pkg("datapasta")` to copy it below.

```{r pictogram-data}
# Number of U.S. Households That Own a Pet, by Type of Animal 
us_pets <- tibble::tribble(
               ~Pet, ~Number,
              "Dog",      69,
              "Cat",    45.3,
  "Freshwater fish",    11.8,
             "Bird",     9.9,
     "Small animal",     6.2,
          "Reptile",     5.7,
            "Horse",     3.5,
   "Saltwater fish",     2.9
  ) %>%
  mutate(Pet = factor(Pet, Pet))
```

## Icons

Then I need to find matching free icons at [fontawesome](https://fontawesome.com/v5/search?q=animal&m=free&s=solid). Make sure you're searching the v5 icons; v6 icons won't work and will result in an impenetrable error-message from `scale_label_pictogram()`.

```{r, eval = FALSE}
icons <- c("dog", "cat", "fish-fins", "crow", "frog", "dragon", "horse", "fish")
ggplot(us_pets, aes(label = Pet, values = Number)) +
  geom_pictogram() +
  scale_label_pictogram(values = icons)
```

<pre><code>## Error in vapply(if (n &gt; length(values)) rep(values[[1]], n) else values, : values must be length 1,
##  but FUN(X[[8]]) result is length 0</code></pre>

Yes, I know I used fish twice, and not many people owned winged dragons, but they were the only reptile!

```{r pictogram-icons}
icons <- c("dog", "cat", "fish", "crow", "frog", "dragon", "horse", "fish")
ggplot(us_pets, aes(label = Pet, values = Number)) +
  geom_pictogram() +
  scale_label_pictogram(values = icons)
```

## Colour

Now, let's add some colour. I'm also going to make the icon size a little smaller.

```{r pictogram-colour}
ggplot(us_pets, aes(label = Pet, values = Number, color = Pet)) +
  geom_pictogram(size = 6.5) +
  scale_label_pictogram(values = icons)
```

I like the ggplot default colours, except for the green fish. I'd rather it be yellow. I found this function to re-create the [ggplot default colour scheme](https://stackoverflow.com/questions/8197559/emulate-ggplot2-default-color-palette).

```{r pictogram-show-col}
ggplotColours <- function(n, h = c(0, 360) + 15){
  h[2] <- h[2] - 360/n
  hcl(h = (seq(h[1], h[2], length = n)), c = 100, l = 65)
}
pet_colours <- ggplotColours(8)
pet_colours[3] <- "#F5C748"
```


```{r pictogram-custom-colour}
ggplot(us_pets, aes(label = Pet, values = Number, color = Pet)) +
  geom_pictogram(size = 6.5) +
  scale_label_pictogram(values = icons) +
  scale_colour_manual(values = pet_colours)
```


## Clean it up

Make sure the coordinates are equal to not stretch out the aspect ratio of the icons, add `theme_enhance_waffle()` to get rid of extraneous background, and add labels to aid interpretation and for the data provenance.

```{r pictogram-clean}
plot <- ggplot(us_pets, aes(label = Pet, values = Number, color = Pet)) +
  geom_pictogram(size = 6.5) +
  scale_label_pictogram(values = icons) +
  scale_colour_manual(values = pet_colours) +
  coord_equal() +
  theme_enhance_waffle() +
  labs(title = "Pet Ownership in America",
       subtitle = "Each icon represents 1 million houeholds",
       caption = "Data from the American Pet Products Association (APPA) 2021-2022 National Pet Owners Survey")

plot
```

## Customise

Finally, use `theme()` to really customise the look. I adjusted the spacing between the items on the legend with `legend.spacing.y`, which requires the guides to be set `byrow` to work. 

```{r pictogram-final, fig.cap = "Number of US households (in millions) with each of 8 common pet types.", fig.alt="Number of US households (in millions) with each of 8 common pet types.  Data from the American Pet Products Association (APPA) 2021-2022 National Pet Owners Survey. Dog=69, Cat=45.3, Freshwater fish=11.8, Bird=9.9, Small animal=6.2, Reptile=5.7, Horse=3.5, Saltwater fish=2.9"}

plot +
  theme(axis.ticks = element_blank(),
        plot.background = element_rect(fill = "black", color = "black"),
        plot.margin = unit(c(.5, .5, .5, .0), 'cm'),
        plot.title = element_text(family = "Market Deco", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        plot.caption.position = "plot",
        panel.background = element_rect(fill = "black", color = "black"),
        legend.background = element_blank(),
        legend.title = element_blank(),
        legend.key = element_blank(),
        legend.spacing.y = unit(.25, 'cm'),
        text = element_text(family = "Avenir", color = "white")) +
  ## important additional element
  guides(color = guide_legend(byrow = TRUE),
         label = guide_legend(byrow = TRUE))
```

## Save

However, I had trouble saving the plot using `ggsave()`. The icons end up garbled.

```{r, fig.alt="Same as above, but all the icons are question marks."}
ggsave("images/day2_garbled.png", width = 8, height = 5)
knitr::include_graphics("images/day2_garbled.png")
```

This turns out to be because `ggsave()` uses ragg by default (HT [Steve Haroz](https://twitter.com/sharoz/status/1510342578268516355)), which isn't playing well with fontawesome icons, so I have to set the device back to `png`.

```{r, fig.alt="fixed"}
ggsave("images/day2.png", width = 8, height = 5, device = png)
knitr::include_graphics("images/day2.png")
```




# Historical

```{r hist-setup}
library(tidyverse)
```


## Population Data

I got this dataset from a class assignment that cites [Our World in Data Burden of Disease](https://ourworldindata.org/burden-of-disease), but I'm still not sure exactly where the historical population data came from, so you can <a href="data/disease-burden-vs-health-expenditure-per-capita.csv" download>get the file here</a>.

```{r hist-data}
pop <- read_csv("data/disease-burden-vs-health-expenditure-per-capita.csv",
                show_col_types = FALSE)

spec(pop)
```

The column names need some cleaning (I prefer to work with column names that are all lowercase with no spaces), and I don't need some of the data.

```{r hist-data-clean}
pop <- read_csv("data/disease-burden-vs-health-expenditure-per-capita.csv",
                col_names = c("region", "code", "year", "population", "continent"),
                skip = 1,
                col_types = "cci--dc")

head(pop)
```

<!--
The continent column seems odd. It looks like maybe this used to be an excel file with merged rows, so now only one row for each region has a continent entry and the rest are NA. I'll make a filtered table with each entry that does have the continent listed, then join that back to the original dataset.

```{r}
continents <- pop %>%
  filter(!is.na(continent)) %>%
  select(code, continent)

pop2 <- pop %>%
  select(-continent) %>%
  left_join(continents, by = "code")
```

-->

## Select relevant data

I just want to plot the population for the 6 major world regions, so I'll filter that and make a quick line plot to see what I've got.

```{r hist-world-regions}
world_regions <- pop %>%
  select(-code, -continent) %>%
  filter(region %in% c("Africa", "Asia", "Europe", "Oceania", "North America", "South America"))
```

```{r hist-plot1}
ggplot(world_regions, aes(x = year, y = population, color = region)) +
  geom_line()
```

## Transform y-axis

The population growth is pretty exponential at the end, so a log transformation of the y-axis might help.

```{r hist-log}
ggplot(world_regions, aes(x = year, y = population, color = region)) +
  geom_line() +
  scale_y_log10()
```

## Region order

It would make more sense if the legend was in the same order as the lines, so I'll turn that column into a factor ordered by the population at the latest year.

```{r hist-region-order}
region_order <- world_regions %>%
  filter(year == max(year)) %>%
  arrange(desc(population)) %>%
  pull(region)

world_regions <- world_regions %>%
  mutate(region = factor(region, region_order))
```

I'll also add a point for each year with data.

```{r hist-order}
ggplot(world_regions, aes(x = year, y = population, color = region)) +
  geom_line() +
  geom_point() +
  scale_y_log10()
```


## Variable x-axis

The data collection isn't even at all. The years go every 1000 from -10000 to 0, then every 100 from 0 to 1700, then every 10 from 1700 to 1800, then every year from 1800 to 2021.

```{r hist-years}
unique(world_regions$year) %>% sort() %>% `[`(1:50)
```

I tried a few x-axis transformations, and they're not straightforward because the x-axis crosses 0, which most transformations can't handle. This was one of the silliest.

```{r hist-log-x}
ggplot(world_regions, aes(x = year, y = population, color = region)) +
  geom_line() +
  geom_point() +
  scale_y_log10() +
  scale_x_continuous(trans = "reciprocal")
```


So I'll add a new column that specifies which time period they're in. I'll replace this text later, so it's probably easiest to give them alphabetic labels now.

```{r hist-time-period}
world_regions <- world_regions %>%
  mutate(time_period = case_when(
      year < 0 ~ "A",
      year < 1700 ~ "B",
      year < 1800 ~ "C",
      year < 2022 ~ "D"))
```


```{r hist-facet}
ggplot(world_regions, aes(x = year, y = population, color = region)) +
  geom_line() +
  geom_point() +
  scale_y_log10() +
  facet_grid(~time_period, scales = "free_x")
  
```


## Clean Up

Now we're getting somewhere, but still need to clean this up a lot. I'm going to remove the panel spacing and expansion so the plots touch each other. I'll also customise the breaks and labels for the y-axis to make that easier to understand, and customise the colours (I do love a rainbow).

```{r hist-cleaner}
# custom colours
rainbow <- c("#983E82","#E2A458","#F5DC70","#59935B","#467AAC","#61589C")

ggplot(world_regions, aes(x = year, y = population, color = region)) +
  geom_line() +
  geom_point() +
  facet_grid(~time_period, scales = "free_x") +
  scale_x_continuous(name = NULL,
                     expand = expansion(0)) +
  scale_y_log10(name = "Population (log scale)",
                breaks = 10^(5:10),
                labels = c("100K", "1M", "10M", "100M", "1B", "10B"),
                limit = c(1e5, 1e10)) +
  scale_color_manual(name = NULL,
                     values = rainbow) +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 90, hjust = 1),
        panel.spacing.x = unit(0, "cm"))
```

However, the borders of each time period don't meet. I can fix that by duplicating the border years and assigning them to the previous time period. 

```{r hist-add-border-years}
borders <- world_regions %>%
  group_by(time_period) %>%
  filter(year == min(year)) %>%
  ungroup() %>%
  filter(time_period != "A") %>%
  mutate(time_period = recode(time_period, B = "A", C = "B", D = "C"))

world_regions2 <- bind_rows(world_regions, borders)
```

Let's also fix the facet labels. The function `as_labeller()` lets you translate between the data labels and custom labels for facets. And set some custom colours and custom x-axis breaks and labels. I moved the legend inside the plot to give the plot more horizontal room.

```{r hist-custom}
# custom facet labels
tp_labels <- c(
  A = "10000BC to 0",
  B = "0 to 1700",
  C = "1700 to 1800",
  D = "1800 to 2021"
)

# custom x-axis breaks and labels
x_breaks <- c(seq(-10000, -2000, 2000),
              seq(0, 1600, 200),
              seq(1700, 1790, 10),
              seq(1800, 2021, 20))

x_labels <- c(paste(seq(10000, 2000, -2000), "BCE"),
              seq(0, 1700, 200),
              seq(1700, 1790, 10),
              seq(1800, 2021, 20))

ggplot(world_regions2, aes(x = year, y = population, color = region)) +
  geom_line() +
  geom_point() +
  facet_grid(~time_period, 
             scales = "free_x", 
             labeller = as_labeller(tp_labels)) +
  scale_x_continuous(name = NULL,
                   breaks = x_breaks,
                   labels = x_labels,
                   expand = expansion(0)) +
  scale_y_log10(name = "Population (log scale)",
                breaks = 10^(5:10),
                labels = c("100K", "1M", "10M", "100M", "1B", "10B"),
                limit = c(1e5, 1e10)) +
  scale_color_manual(name = NULL,
                     values = rainbow) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        panel.spacing.x = unit(0, "cm"),
        legend.background = element_rect(fill = "transparent"),
        legend.position = c(.1, .75) )
```


## Change time periods

I changed by mind about 1700 to 1800. This plot gives it too much prominence. so I'll combine it with 1800+. It looked weird to specify "BCE" only for the years before 0, so I added "CE" (Common Era) to the years after 0 and adjusted the angle and number of labels to make it easier to read.

```{r}
# recode time period to 3 periods (merge C and D)
world_regions3 <- world_regions2 %>%
  mutate(time_period = recode(time_period, A = "A", B = "B", C = "C", D = "C"))

# remake facet labels
tp_labels <- c(
  A = "10000 BCE to 0",
  B = "0 to 1700 CE",
  C = "1700 CE to 2021 CE"
)

# remake x-axis breaks and labels
x_breaks <- c(seq(-10000, -2000, 2000),
              seq(0, 1500, 300),
              seq(1700, 2021, 50))

x_labels <- c(paste(seq(10000, 2000, -2000), "BCE"),
              paste(seq(0, 1500, 300), "CE"),
              paste(seq(1700, 2021, 50), "CE"))
```



```{r hist-3-time-periods}
ggplot(world_regions3, aes(x = year, y = population, color = region)) +
  geom_line() +
  geom_point(size = 1, alpha = 0.5) +
  facet_grid(~time_period, 
             scales = "free_x", 
             labeller = as_labeller(tp_labels)) +
  scale_x_continuous(name = NULL,
                   breaks = x_breaks,
                   labels = x_labels,
                   expand = expansion(0)) +
  scale_y_log10(name = "Population (log scale)",
                breaks = 10^(5:10),
                labels = c("100K", "1M", "10M", "100M", "1B", "10B"),
                limit = c(1e5, 1e10)) +
  scale_color_manual(name = NULL,
                     values = rainbow) +
  labs(title = "World Population (Historical Estimates)",
       caption = "Data from Our World in Data | Plot by @lisadebruine") +
  theme_bw() +
  theme(text = element_text(family = "Avenir"),
        axis.text.x = element_text(angle = 30, hjust = 1),
        panel.spacing.x = unit(0, "cm"),
        legend.background = element_rect(fill = "transparent"),
        legend.position = c(.1, .75),
        panel.grid.minor = element_blank(),
        plot.title = element_text(family = "Market Deco"))
```

```{r, include = FALSE}
ggsave("images/day3.png", width = 8, height = 4.5)
```



# Flora

```{r}
library(tidyverse) # always useful
library(rsvg) # to convert SVG to other formats
library(glue) # for editing SVG text
```

I'm going a little off-piste today. I was inspired by all of these [stock infographics](https://www.vectorstock.com/royalty-free-vectors/chart-flower-infographic-options-vectors), but I wondered if I could make something similar with code. You probably can do this with ggplot and annotations, but I wanted to try something different.

```{r flora-examples, fig.cap="Flower infographics from vectorstock.com"}
knitr::include_graphics("images/flower_infographics.png")
```


## SVG

I have some experience making SVGs (scalable vector graphics), but I always have to look things up. [W3Schools](https://www.w3schools.com/graphics/svg_intro.asp) is my favourite source for quick tutorials on web stuff. I used it a ton to make this chart.

While I was developing this code, I needed to have a quick look at the images a lot, and couldn't figure out an efficient way to view SVGs, so I wrote a function that converts the svg text to a PNG tempfile and displays it in my Rmd, but only when I'm running the code interactively. 

```{r}
viewsvg <- function(svg, width = 5, height = 5, dpi = 150) {
  if (interactive() &&
      !isTRUE(getOption("knitr.in.progress"))) {
    imgpath <- tempfile(fileext = ".png")
    rsvg::rsvg_png(svg = charToRaw(svg),
                   file = imgpath,
                   width = width*dpi, height = height*dpi)
    knitr::include_graphics(imgpath)
  } else {
    cat(svg)
  }
}
```

It outputs the SVG as html when knitting. All of the images below are created with a code chunk that looks like this:

```{r, eval = FALSE, verbatim="r, results='asis', echo = FALSE"}
viewsvg(svg)
```


## Flower Petals

First, I need a function to figure out the coordinates of regular polygons. 

```{r}
poly_coords <- function(n = 6, r = 1, cx = 0, cy = 0, rot = 0, digits = 2) {
  x = map_dbl(0:(n-1), ~{ cx + r * cos(2 * pi * .x / n + rot) })
  y = map_dbl(0:(n-1), ~{ cy + r * sin(2 * pi * .x / n + rot) })
  
  list(
    x = round(x, digits),
    y = round(y, digits)
  )
}

poly_coords(n = 6)
```

Now, make `n` circles with radius `r` that are `petal_dist` away from the center of the flower.

```{r}
n <- 6
r <- 200
petal_dist <- 300
cx <- 500
cy <- 500

coords <- poly_coords(n, petal_dist, cx, cy)
petals <- glue('    <circle cx="{coords$x}" cy="{coords$y}" r="{r}" fill="{rainbow(n)}" />') %>%
  paste(collapse = "\n")

svg <- paste("<svg viewBox = '0 0 {2*cx} {2*cy}'>",
        petals, 
      "</svg>",
      sep = "\n") %>%
  glue()
```


```{r, results='asis', echo = FALSE}
viewsvg(svg)
```

## Rotate

Rotate them so the red is at 12:00.

```{r}
rot <- -pi/2

coords <- poly_coords(n, petal_dist, cx, cy, rot)
petals <- glue('    <circle cx="{coords$x}" cy="{coords$y}" r="{r}" fill="{rainbow(n)}" />') %>%
  paste(collapse = "\n")

svg <- paste("<svg viewBox = '0 0 {2*cx} {2*cy}'>",
        petals, 
      "</svg>",
      sep = "\n") %>%
  glue()
```


```{r, results='asis', echo = FALSE}
viewsvg(svg)
```


## Fix the Overlap

When they overlap, the last petal is on top of the first, so we need to replot the left half of that. It took me forever to figure out how to plot the left half of a circle with `<path>` :(

```{r}
coords <- poly_coords(n, petal_dist, cx, cy, rot)
petals <- glue('    <circle cx="{coords$x}" cy="{coords$y}" r="{r}" fill="{rainbow(n)}" />') %>%
  paste(collapse = "\n")

x1 <- coords$x[[1]]
y1 <- coords$y[[1]]
petal_fix <- glue('    <g transform="rotate({rot*180/pi}, {x1}, {y1})">
       <path d="M {x1-r} {y1}
       A {r} {r} 0 0 1 {x1+r} {y1}
       L {x1-r} {y1}
       Z" 
       fill="{rainbow(n)[[1]]}" /></g>')

svg <- paste("<svg viewBox = '0 0 {2*cx} {2*cy}'>",
        petals, petal_fix, 
      "</svg>",
      sep = "\n") %>%
  glue()
```


```{r, results='asis', echo = FALSE}
viewsvg(svg)
```


Now I want to add a center hexagon that just touches each petal.

```{r}
center <- poly_coords(n, petal_dist-r, cx, cy, rot) %>%
  glue("{cc$x},{cc$y}", cc = .) %>%
  paste(collapse = " ") %>%
  glue('<polygon points="{pts}" fill="grey" />', pts = .)

svg <- paste("<svg viewBox = '0 0 {2*cx} {2*cy}'>", 
      center,
      petals, petal_fix,
      "</svg>",
      sep = "\n") %>%
  glue()
```


```{r, results='asis', echo = FALSE}
viewsvg(svg)
```


## 7 Petals

```{r}
n          <- 7
rot        <- 8.5*pi/7
petal_dist <- 400
r          <- 200
cx         <- 1.1 * (petal_dist + r)
cy         <- cx

center <- poly_coords(n, petal_dist-r, cx, cy, rot) %>%
  glue("{cc$x},{cc$y}", cc = .) %>%
  paste(collapse = " ") %>%
  glue('<polygon points="{pts}" fill="grey" />', pts = .)

coords <- poly_coords(n, petal_dist, cx, cy, rot)
petals <- glue('    <circle cx="{coords$x}" cy="{coords$y}" r="{r}" fill="{rainbow(n)}" />') %>%
  paste(collapse = "\n")

x1 <- coords$x[[1]]
y1 <- coords$y[[1]]
petal_fix <- glue('    <g transform="rotate({rot*180/pi}, {x1}, {y1})">
       <path d="M {x1-r} {y1}
       A {r} {r} 0 0 1 {x1+r} {y1}
       L {x1-r} {y1}
       Z" 
       fill="{rainbow(n)[[1]]}" /></g>')


text <- glue('    <text x="{coords$x}" y="{coords$y+40}">{LETTERS[1:n]}</text>"') %>%
  paste(collapse = "\n")

svg_style <- '<style type="text/css">
svg { 
  font-family: sans-serif;
  font-size: 80px; 
  text-anchor: middle; 
  fill: white;
}
</style>'

svg <- paste("<svg viewBox = '0 0 {{2*cx}} {{2*cy}}'>", 
             svg_style,
             center,
             '<text x="{{cx}}" y="{{cy-20}}">All of the</text>',
             '<text x="{{cx}}" y="{{cy+90}}">Things</text>',
             petals, petal_fix, text, "</svg>",
             sep = "\n") %>%
  glue(.open = "{{", .close = "}}")

```


```{r, results='asis', echo = FALSE}
viewsvg(svg)
```

## Make a Function

Now I just need to wrap this all in a function so I can change the things I need. I also added transparency to the petals, which necessitated making the two halves of the first petal separately, otherwise the overlap fix increases the opacity of half the petal if there's any transparency. 

```{r}
poly_coords <- function(n = 6, r = 1, cx = 0, cy = 0, rot = 0, digits = 2) {
  x = map_dbl(0:(n-1), ~{ cx + r * cos(2 * pi * .x / n + rot) })
  y = map_dbl(0:(n-1), ~{ cy + r * sin(2 * pi * .x / n + rot) })
  
  list(
    x = round(x, digits),
    y = round(y, digits)
  )
}

flower <- function(n = 6, petal_dist = 500, r = 250, rot = -pi/2,
                   petal_text = LETTERS[1:n],
                   center_text = c("All of the", "Things"),
                   petal_text_size = r/2,
                   center_text_size = petal_dist/6,
                   center_text_offsets = c(-0.2, +0.9) * center_text_size,
                   petal_colors = rainbow(n),
                   petal_alpha = 1.0,
                   center_color = "#808080",
                   petal_text_color = "white",
                   center_text_color = petal_text_color) {
  
  # calculate centre
  cx <- 1.1 * (petal_dist + r)
  cy <- cx
  
  # make centre polygon
  center <- poly_coords(n, petal_dist-r, cx, cy, rot) %>%
    glue("{cc$x},{cc$y}", cc = .) %>%
    paste(collapse = " ") %>%
    glue('<polygon points="{pts}" fill="{center_color}" />', pts = .)
  
  # make center texts
  center_texts <- glue('    <text x="{cx}" y="{cy+center_text_offsets}" fill="{center_text_color}" font-size="{center_text_size}px">{center_text}</text>') %>%
    paste(collapse = "\n")
  
  # make petals
  coords <- poly_coords(n, petal_dist, cx, cy, rot)
  petals <- glue('    <circle cx="{coords$x}" cy="{coords$y}" r="{r}" fill="{rainbow(n)}" />') %>%
    paste(collapse = "\n")
  
  x1 <- coords$x[[1]]
  y1 <- coords$y[[1]]
  petal_fix1 <- glue('    <g transform="rotate({(rot+pi)*180/pi}, {x1}, {y1})">
         <path d="M {x1-r} {y1}
         A {r} {r} 0 0 1 {x1+r} {y1}
         L {x1-r} {y1}
         Z" 
         fill="{rainbow(n)[[1]]}" fill-opacity="{petal_alpha}" /></g>')
  
  petal_fix2 <- glue('    <g transform="rotate({rot*180/pi}, {x1}, {y1})">
         <path d="M {x1-r} {y1}
         A {r} {r} 0 0 1 {x1+r} {y1}
         L {x1-r} {y1}
         Z" 
         fill="{rainbow(n)[[1]]}" fill-opacity="{petal_alpha}" /></g>')
  
  # make petal text
  petals_text <- glue('    <text x="{coords$x}" y="{coords$y+petal_text_size/2}">{petal_text}</text>"') %>%
    paste(collapse = "\n")
  
  
  # general styles
  svg_style <- '<style type="text/css">
  svg { 
    font-family: sans-serif;
    font-size: {{petal_text_size}}px; 
    text-anchor: middle; 
    fill: {{petal_text_color}};
  }
</style>'
  
  svg <- paste("<svg viewBox = '0 0 {{2*cx}} {{2*cy}}'>", 
               svg_style,
               center, center_texts,
               petal_fix1, petals, petal_fix2, petals_text, 
               "</svg>",
               sep = "\n") %>%
    glue(.open = "{{", .close = "}}")
  
  svg
}
```

Test the defaults.

```{r}
svg <- flower()
```


```{r, results='asis', echo = FALSE}
viewsvg(svg)
```

## Original Pride Flag

Test the customisability by making a chart with the meaning of the 8 colours of the original pride flag.

```{r}
svg <- flower(n = 8, petal_dist = 400, r = 200,
              petal_colors = c("#FF66B1", "#FF0000", "#FF8F1A", "#FEFF3A",
                               "#008F1D", "#00C0C0", "#420095", "#8F008B"),
              petal_alpha = 0.8,
              petal_text = c("Sex", "Life", "Healing", "Sunlight",
                             "Nature", "Magic/Art", "Serenity", "Spirit"),
              center_text = c("Original", "Pride", "Flag"),
              center_text_size = 80,
              center_text_offsets = c(-60, 40, 140),
              petal_text_color = "#222222",
              petal_text_size = 70,
              center_color = "black",
              center_text_color = "white"
)
```


```{r, results='asis', echo = FALSE}
viewsvg(svg)
```

## Save as SVG or PNG

You can display your SVG directly in a website by setting `results='asis'` in the code chunk header. It will display it full size unless you use another method to constrain the image size. I set a css style of `svg { width: 100%; }`.

```{r, results='asis'}
cat(svg)
```

You can write it to an svg file, or use svgr to convert to an image. 

```{r}
write(svg, "images/day4.svg")
rsvg::rsvg_png(svg = charToRaw(svg), 
               file = "images/day4.png", 
               width = 8*150, height = 8*150)

knitr::include_graphics("images/day4.png")
```





# Slope

# OWID
