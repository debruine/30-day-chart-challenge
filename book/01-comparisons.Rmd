# (PART) Comparisons {-}

# Part-to-whole

```{r}
library(treemap)
library(faux)
library(tidyverse)
```

I've been wanting to get more familiar with treemap plots. 

## Simulate data

I always like to start my exploration with simulated data. The mixed design simulation functions below are from [faux](https://debruine.github.io/faux/articles/sim_mixed.html).

Make a school with 5 grades, 1-4 classes per grade, and 15-35 students per class. Get some random names from the 2010 Scottish babies.

```{r pth-data-sim}
set.seed(8675309) # for reproducible data simulation

school <- add_random(grade = 5) %>%
  add_random(class = sample(1:4, nrow(.), TRUE), 
             .nested_in = "grade") %>%
  add_random(student = sample(15:35, nrow(.), TRUE), 
             .nested_in = "class") %>%
  mutate(name = sample(size = nrow(.),
                       x = ukbabynames::scotbabynames %>%
                         filter(year == 2010) %>%
                         pull(name)))

head(school)
```

## Basic Treemap

The basic version is OK, but I think we can do better here.

```{r pth-treemap-basic}
school %>% 
  count(grade, class) %>%
  treemap(
    index = c("grade", "class"), 
    vSize = "n"
  )
```

## Adjust Labels

First, I'll adjust the label size and alignment. I adapted this code from a book that Emily Nordmann and I recently wrote: [Applied Data Skills](https://psyteachr.github.io/ads-v1/custom.html#treemap). For `fontsize.labels` and `align.labels`, I added vector names to help me remember which is which, but the names aren't used by `treemap()` at all, just the order.

The class labels aligned to the bottom right are too close to the edges, so give them some padding with `xmod.labels` and `ymod.labels`. I'm also going to remove the transparent grey label background with `bg.labels = 0`

```{r pth-treemap-labels}
school %>% 
  count(grade, class) %>%
  treemap(
    index = c("grade", "class"), 
    vSize = "n", 
    title = "",
    # set different label sizes for each type of label
    fontsize.labels = c(grade = 30, class = 15), 
    # remove shaded background
    bg.labels = 0,
    # set different alignments for two label types
    align.labels = list(
      grade = c("left", "top"), 
      class = c("right", "bottom")
    ),
    xmod.labels = c(0, -.1), # nudge class labels left
    ymod.labels = c(0, .1)   # nudge class labels up
  )
```

## Colour scheme

I'd like to use the #30DayChartChallenge theme colours for my plots, so let's set that up. I'm going to name the colours after the chapter they represent.

```{r pth-dcc-colours}
dcc_theme <- list(
  comp = "#4864DB", # ~royalblue
  dist = "#10D4CF", # ~darkturquoise
  rels = "#8DEA74", # ~lightgreen
  time = "#F5C748", # ~tan1
  cert = "#EA4E11"  # ~orangered2
)
```

```{r pth-treemap-colours}
school %>% 
  count(grade, class) %>%
  treemap(
    index = c("grade", "class"), 
    vSize = "n", 
    title = "",
    palette = dcc_theme,
    fontsize.labels = c(grade = 30, class = 10), 
    bg.labels = 0,
    align.labels = list(
      grade = c("left", "top"), 
      class = c("center", "center")
    ),
    xmod.labels = c(0, -.1),
    ymod.labels = c(0, .1)
  )
```

## Change text

Now I want to upgrade the labels. It's probably easiest to do this in the data using `mutate()`. I'll set them to the kind of primary school grade labels we use in Scotland, where each grade is P1, P2, ... and each class within a grade gets a letter suffix. 

```{r school2}
school2 <- school %>% 
  count(grade, class) %>%
  mutate(grade = gsub("grade", "P", grade)) %>%
  group_by(grade) %>%
  mutate(class = paste0(grade, letters[1:n()])) %>%
  ungroup() %>%
  mutate(class = paste0(class, "\nn = ", n))
```

Finally, make the borders thicker. It's starting to look like a Mondrian!.

```{r pth-treemap-final, fig.cap = "Treemap plot of classes nested in grades (P1 to P5). There are 2-4 classes in each grade with 16-35 students. The size of each box represents the size of the class, and the colour of the box represents the grade."}
school2 %>%
  treemap(
    index = c("grade", "class"), 
    vSize = "n", 
    title = "",
    palette = dcc_theme,
    fontcolor.labels = "white",
    fontsize.labels = c(grade = 30, class = 15), 
    bg.labels = 0,
    align.labels = list(
      grade = c("left", "top"), 
      class = c("right", "bottom")
    ),
    xmod.labels = c(0, -.1),
    ymod.labels = c(0, .1),
    border.lwds = 5, # thicker borders
  )
```


```{r, include = FALSE}
ggsave("images/day1.png", width = 8, height = 4.5)
```

# Pictogram

I recently discovered the `r pkg("waffle", "https://github.com/hrbrmstr/waffle/")` package for making waffle plots. Emily and I refuse to teach students on our [Applied Data Skills](https://psyteachr.github.io/ads-v1/) course how to make pie charts, and these are a sweet alternative. 

```{r}
#devtools::install_github("hrbrmstr/waffle")
library(tidyverse)
library(waffle)
```


## Pictogram data

Pictograms are generally used for counts, and pets are my go-to example for unordered categorical data (even though ferrets are obviously the best).

I found a table of [pet ownership in the USA](https://www.iii.org/fact-statistic/facts-statistics-pet-ownership-and-insurance). They had an excel file download option for the data, but the file was corrupted, so I used `r pkg("datapasta")` to copy it below.

```{r pictogram-data}
# Number of U.S. Households That Own a Pet, by Type of Animal 
us_pets <- tibble::tribble(
               ~Pet, ~Number,
              "Dog",      69,
              "Cat",    45.3,
  "Freshwater fish",    11.8,
             "Bird",     9.9,
     "Small animal",     6.2,
          "Reptile",     5.7,
            "Horse",     3.5,
   "Saltwater fish",     2.9
  ) %>%
  mutate(Pet = factor(Pet, Pet))
```

## Icons

Then I need to find matching free icons at [fontawesome](https://fontawesome.com/v5/search?q=animal&m=free&s=solid). Make sure you're searching the v5 icons; v6 icons won't work and will result in an impenetrable error-message from `scale_label_pictogram()`.

```{r, eval = FALSE}
icons <- c("dog", "cat", "fish-fins", "crow", "frog", "dragon", "horse", "fish")
ggplot(us_pets, aes(label = Pet, values = Number)) +
  geom_pictogram() +
  scale_label_pictogram(values = icons)
```

<pre><code>## Error in vapply(if (n &gt; length(values)) rep(values[[1]], n) else values, : values must be length 1,
##  but FUN(X[[8]]) result is length 0</code></pre>

Yes, I know I used fish twice, and not many people owned winged dragons, but they were the only reptile!

```{r pictogram-icons}
icons <- c("dog", "cat", "fish", "crow", "frog", "dragon", "horse", "fish")
ggplot(us_pets, aes(label = Pet, values = Number)) +
  geom_pictogram() +
  scale_label_pictogram(values = icons)
```

## Colour

Now, let's add some colour. I'm also going to make the icon size a little smaller.

```{r pictogram-colour}
ggplot(us_pets, aes(label = Pet, values = Number, color = Pet)) +
  geom_pictogram(size = 6.5) +
  scale_label_pictogram(values = icons)
```

I like the ggplot default colours, except for the green fish. I'd rather it be yellow. I found this function to re-create the [ggplot default colour scheme](https://stackoverflow.com/questions/8197559/emulate-ggplot2-default-color-palette).

```{r pictogram-show-col}
ggplotColours <- function(n, h = c(0, 360) + 15){
  h[2] <- h[2] - 360/n
  hcl(h = (seq(h[1], h[2], length = n)), c = 100, l = 65)
}
pet_colours <- ggplotColours(8)
pet_colours[3] <- "#F5C748"
```


```{r pictogram-custom-colour}
ggplot(us_pets, aes(label = Pet, values = Number, color = Pet)) +
  geom_pictogram(size = 6.5) +
  scale_label_pictogram(values = icons) +
  scale_colour_manual(values = pet_colours)
```


## Clean it up

Make sure the coordinates are equal to not stretch out the aspect ratio of the icons, add `theme_enhance_waffle()` to get rid of extraneous background, and add labels to aid interpretation and for the data provenance.

```{r pictogram-clean}
plot <- ggplot(us_pets, aes(label = Pet, values = Number, color = Pet)) +
  geom_pictogram(size = 6.5) +
  scale_label_pictogram(values = icons) +
  scale_colour_manual(values = pet_colours) +
  coord_equal() +
  theme_enhance_waffle() +
  labs(title = "Pet Ownership in America",
       subtitle = "Each icon represents 1 million houeholds",
       caption = "Data from the American Pet Products Association (APPA) 2021-2022 National Pet Owners Survey")

plot
```

## Customise

Finally, use `theme()` to really customise the look. I adjusted the spacing between the items on the legend with `legend.spacing.y`, which requires the guides to be set `byrow` to work. 

```{r pictogram-final, fig.cap = "Number of US households (in millions) with each of 8 common pet types.", fig.alt="Number of US households (in millions) with each of 8 common pet types.  Data from the American Pet Products Association (APPA) 2021-2022 National Pet Owners Survey. Dog=69, Cat=45.3, Freshwater fish=11.8, Bird=9.9, Small animal=6.2, Reptile=5.7, Horse=3.5, Saltwater fish=2.9"}

plot +
  theme(axis.ticks = element_blank(),
        plot.background = element_rect(fill = "black", color = "black"),
        plot.margin = unit(c(.5, .5, .5, .0), 'cm'),
        plot.title = element_text(family = "Market Deco", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        plot.caption.position = "plot",
        panel.background = element_rect(fill = "black", color = "black"),
        legend.background = element_blank(),
        legend.title = element_blank(),
        legend.key = element_blank(),
        legend.spacing.y = unit(.25, 'cm'),
        text = element_text(family = "Avenir", color = "white")) +
  ## important additional element
  guides(color = guide_legend(byrow = TRUE),
         label = guide_legend(byrow = TRUE))
```

## Save

However, I had trouble saving the plot using `ggsave()`. The icons end up garbled.

```{r, fig.alt="Same as above, but all the icons are question marks."}
ggsave("images/day2_garbled.png", width = 8, height = 5)
knitr::include_graphics("images/day2_garbled.png")
```

This turns out to be because `ggsave()` uses ragg by default (HT [Steve Haroz](https://twitter.com/sharoz/status/1510342578268516355)), which isn't playing well with fontawesome icons, so I have to set the device back to `png`.

```{r, fig.alt="fixed"}
ggsave("images/day2.png", width = 8, height = 5, device = png)
knitr::include_graphics("images/day2.png")
```




# Historical

```{r hist-setup}
library(tidyverse)
```


## Population Data

I got this dataset from a class assignment that cites [Our World in Data Burden of Disease](https://ourworldindata.org/burden-of-disease), but I'm still not sure exactly where the historical population data came from, so you can <a href="data/disease-burden-vs-health-expenditure-per-capita.csv" download>get the file here</a>.

```{r hist-data}
pop <- read_csv("data/disease-burden-vs-health-expenditure-per-capita.csv",
                show_col_types = FALSE)

spec(pop)
```

The column names need some cleaning (I prefer to work with column names that are all lowercase with no spaces), and I don't need some of the data.

```{r hist-data-clean}
pop <- read_csv("data/disease-burden-vs-health-expenditure-per-capita.csv",
                col_names = c("region", "code", "year", "population", "continent"),
                skip = 1,
                col_types = "cci--dc")

head(pop)
```

<!--
The continent column seems odd. It looks like maybe this used to be an excel file with merged rows, so now only one row for each region has a continent entry and the rest are NA. I'll make a filtered table with each entry that does have the continent listed, then join that back to the original dataset.

```{r}
continents <- pop %>%
  filter(!is.na(continent)) %>%
  select(code, continent)

pop2 <- pop %>%
  select(-continent) %>%
  left_join(continents, by = "code")
```

-->

## Select relevant data

I just want to plot the population for the 6 major world regions, so I'll filter that and make a quick line plot to see what I've got.

```{r hist-world-regions}
world_regions <- pop %>%
  select(-code, -continent) %>%
  filter(region %in% c("Africa", "Asia", "Europe", "Oceania", "North America", "South America"))
```

```{r hist-plot1}
ggplot(world_regions, aes(x = year, y = population, color = region)) +
  geom_line()
```

## Transform y-axis

The population growth is pretty exponential at the end, so a log transformation of the y-axis might help.

```{r hist-log}
ggplot(world_regions, aes(x = year, y = population, color = region)) +
  geom_line() +
  scale_y_log10()
```

## Region order

It would make more sense if the legend was in the same order as the lines, so I'll turn that column into a factor ordered by the population at the latest year.

```{r hist-region-order}
region_order <- world_regions %>%
  filter(year == max(year)) %>%
  arrange(desc(population)) %>%
  pull(region)

world_regions <- world_regions %>%
  mutate(region = factor(region, region_order))
```

I'll also add a point for each year with data.

```{r hist-order}
ggplot(world_regions, aes(x = year, y = population, color = region)) +
  geom_line() +
  geom_point() +
  scale_y_log10()
```


## Variable x-axis

The data collection isn't even at all. The years go every 1000 from -10000 to 0, then every 100 from 0 to 1700, then every 10 from 1700 to 1800, then every year from 1800 to 2021.

```{r hist-years}
unique(world_regions$year) %>% sort() %>% `[`(1:50)
```

I tried a few x-axis transformations, and they're not straightforward because the x-axis crosses 0, which most transformations can't handle. This was one of the silliest.

```{r hist-log-x}
ggplot(world_regions, aes(x = year, y = population, color = region)) +
  geom_line() +
  geom_point() +
  scale_y_log10() +
  scale_x_continuous(trans = "reciprocal")
```


So I'll add a new column that specifies which time period they're in. I'll replace this text later, so it's probably easiest to give them alphabetic labels now.

```{r hist-time-period}
world_regions <- world_regions %>%
  mutate(time_period = case_when(
      year < 0 ~ "A",
      year < 1700 ~ "B",
      year < 1800 ~ "C",
      year < 2022 ~ "D"))
```


```{r hist-facet}
ggplot(world_regions, aes(x = year, y = population, color = region)) +
  geom_line() +
  geom_point() +
  scale_y_log10() +
  facet_grid(~time_period, scales = "free_x")
  
```


## Clean Up

Now we're getting somewhere, but still need to clean this up a lot. I'm going to remove the panel spacing and expansion so the plots touch each other. I'll also customise the breaks and labels for the y-axis to make that easier to understand, and customise the colours (I do love a rainbow).

```{r hist-cleaner}
# custom colours
rainbow <- c("#983E82","#E2A458","#F5DC70","#59935B","#467AAC","#61589C")

ggplot(world_regions, aes(x = year, y = population, color = region)) +
  geom_line() +
  geom_point() +
  facet_grid(~time_period, scales = "free_x") +
  scale_x_continuous(name = NULL,
                     expand = expansion(0)) +
  scale_y_log10(name = "Population (log scale)",
                breaks = 10^(5:10),
                labels = c("100K", "1M", "10M", "100M", "1B", "10B"),
                limit = c(1e5, 1e10)) +
  scale_color_manual(name = NULL,
                     values = rainbow) +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 90, hjust = 1),
        panel.spacing.x = unit(0, "cm"))
```

However, the borders of each time period don't meet. I can fix that by duplicating the border years and assigning them to the previous time period. 

```{r hist-add-border-years}
borders <- world_regions %>%
  group_by(time_period) %>%
  filter(year == min(year)) %>%
  ungroup() %>%
  filter(time_period != "A") %>%
  mutate(time_period = recode(time_period, B = "A", C = "B", D = "C"))

world_regions2 <- bind_rows(world_regions, borders)
```

Let's also fix the facet labels. The function `as_labeller()` lets you translate between the data labels and custom labels for facets. And set some custom colours and custom x-axis breaks and labels. I moved the legend inside the plot to give the plot more horizontal room.

```{r hist-custom}
# custom facet labels
tp_labels <- c(
  A = "10000BC to 0",
  B = "0 to 1700",
  C = "1700 to 1800",
  D = "1800 to 2021"
)

# custom x-axis breaks and labels
x_breaks <- c(seq(-10000, -2000, 2000),
              seq(0, 1600, 200),
              seq(1700, 1790, 10),
              seq(1800, 2021, 20))

x_labels <- c(paste(seq(10000, 2000, -2000), "BCE"),
              seq(0, 1700, 200),
              seq(1700, 1790, 10),
              seq(1800, 2021, 20))

ggplot(world_regions2, aes(x = year, y = population, color = region)) +
  geom_line() +
  geom_point() +
  facet_grid(~time_period, 
             scales = "free_x", 
             labeller = as_labeller(tp_labels)) +
  scale_x_continuous(name = NULL,
                   breaks = x_breaks,
                   labels = x_labels,
                   expand = expansion(0)) +
  scale_y_log10(name = "Population (log scale)",
                breaks = 10^(5:10),
                labels = c("100K", "1M", "10M", "100M", "1B", "10B"),
                limit = c(1e5, 1e10)) +
  scale_color_manual(name = NULL,
                     values = rainbow) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        panel.spacing.x = unit(0, "cm"),
        legend.background = element_rect(fill = "transparent"),
        legend.position = c(.1, .75) )
```


## Change time periods

I changed by mind about 1700 to 1800. This plot gives it too much prominence. so I'll combine it with 1800+. It looked weird to specify "BCE" only for the years before 0, so I added "CE" (Common Era) to the years after 0 and adjusted the angle and number of labels to make it easier to read.

```{r}
# recode time period to 3 periods (merge C and D)
world_regions3 <- world_regions2 %>%
  mutate(time_period = recode(time_period, A = "A", B = "B", C = "C", D = "C"))

# remake facet labels
tp_labels <- c(
  A = "10000 BCE to 0",
  B = "0 to 1700 CE",
  C = "1700 CE to 2021 CE"
)

# remake x-axis breaks and labels
x_breaks <- c(seq(-10000, -2000, 2000),
              seq(0, 1500, 300),
              seq(1700, 2021, 50))

x_labels <- c(paste(seq(10000, 2000, -2000), "BCE"),
              paste(seq(0, 1500, 300), "CE"),
              paste(seq(1700, 2021, 50), "CE"))
```



```{r hist-3-time-periods}
ggplot(world_regions3, aes(x = year, y = population, color = region)) +
  geom_line() +
  geom_point(size = 1, alpha = 0.5) +
  facet_grid(~time_period, 
             scales = "free_x", 
             labeller = as_labeller(tp_labels)) +
  scale_x_continuous(name = NULL,
                   breaks = x_breaks,
                   labels = x_labels,
                   expand = expansion(0)) +
  scale_y_log10(name = "Population (log scale)",
                breaks = 10^(5:10),
                labels = c("100K", "1M", "10M", "100M", "1B", "10B"),
                limit = c(1e5, 1e10)) +
  scale_color_manual(name = NULL,
                     values = rainbow) +
  labs(title = "World Population (Historical Estimates)",
       caption = "Data from Our World in Data | Plot by @lisadebruine") +
  theme_bw() +
  theme(text = element_text(family = "Avenir"),
        axis.text.x = element_text(angle = 30, hjust = 1),
        panel.spacing.x = unit(0, "cm"),
        legend.background = element_rect(fill = "transparent"),
        legend.position = c(.1, .75),
        panel.grid.minor = element_blank(),
        plot.title = element_text(family = "Market Deco"))
```

```{r, include = FALSE}
ggsave("images/day3.png", width = 8, height = 4.5)
```



# Flora

# Slope

# OWID
